{
  "version": 3,
  "sources": ["..\\src\\server.ts", "..\\src\\index.bundle.ts", "..\\src\\lib\\ericchase\\Utility\\Console.ts", "..\\src\\lib\\ericchase\\Web API\\Node_Utility.ts"],
  "sourcesContent": [
    "const host = '127.0.0.1';\nconst port = '8000';\n\nexport const server_ws = `ws://${host}:${port}`;\nexport const server_http = `http://${host}:${port}`;\n",
    "import { server_http, server_ws } from './server.js';\n\nimport { DatabaseDriver } from './database-drivers/dbdriver.module.js';\nimport { ConsoleError } from './lib/ericchase/Utility/Console.js';\nimport { NodeRef } from './lib/ericchase/Web API/Node_Utility.js';\n\n//                                                                          \\\\\n//\n// Hot Reload\n\nconst socket = new WebSocket(server_ws);\nsocket.addEventListener('message', (event) => {\n  if (event.data === 'reload') {\n    window.location.reload();\n  }\n});\n\n//                                                                          \\\\\n//\n// Postgres Queries\n\nconst db_query = DatabaseDriver.getLocalhost(server_http);\n\nasync function DatabaseConnected(): Promise<boolean> {\n  try {\n    const q = `SELECT 1`;\n    await db_query(q, []);\n    return true;\n  } catch (error) {\n    throw error;\n  }\n}\n\nasync function CreateTable(name: string): Promise<void> {\n  const q = `\n      CREATE TABLE ${name} (\n        id SERIAL PRIMARY KEY,\n        name TEXT NOT NULL,\n        email TEXT NOT NULL\n      );\n    `;\n  await db_query(q, []);\n}\nasync function TableExists(name: string): Promise<boolean> {\n  const q = `\n    SELECT EXISTS (\n      SELECT 1 \n      FROM information_schema.tables \n      WHERE table_schema = 'public' \n      AND table_name = $1\n    );\n  `;\n  const { exists } = (await db_query(q, [name]))[0];\n  return exists ?? false;\n}\n\n//                                                                          \\\\\n//\n// Database Functions\n\nasync function EnsureTableExists(name: string): Promise<{ created: boolean; exists: boolean }> {\n  try {\n    if ((await TableExists(name)) === true) {\n      return { created: false, exists: true };\n    } else {\n      await CreateTable(name);\n      if ((await TableExists(name)) === true) {\n        return { created: true, exists: true };\n      }\n    }\n  } catch (error) {\n    ConsoleError(error);\n  }\n  return { created: false, exists: false };\n}\n\n//                                                                          \\\\\n\nclass Page {\n  divMessages: HTMLDivElement;\n  constructor() {\n    this.divMessages = NodeRef(document.querySelector('#messages')).as(HTMLDivElement);\n  }\n  addMessage(text: string) {\n    try {\n      const div = document.createElement('div');\n      const pre = document.createElement('pre');\n      pre.textContent = text;\n      div.appendChild(pre);\n      this.divMessages.prepend(div);\n      // scroll div into view\n      div.scrollIntoView(false);\n      return div;\n    } catch (error) {\n      ConsoleError(error);\n    }\n  }\n}\n\nconst page = new Page();\n\ntry {\n  if (await DatabaseConnected()) {\n    const tableName = 'test';\n    const { created, exists } = await EnsureTableExists(tableName);\n    if (created) {\n      page.addMessage('Table created.');\n    } else if (exists) {\n      page.addMessage('Table exists.');\n    } else {\n      page.addMessage('Table creation failed.');\n    }\n  }\n} catch (error: any) {\n  page.addMessage(error);\n  page.addMessage('Is server running? Check api endpoint.');\n}\n",
    "export function ConsoleLog(...items: any[]) {\n  console['log'](...items);\n}\nexport function ConsoleError(...items: any[]) {\n  console['error'](...items);\n}\n",
    "export class CNodeRef {\n  node: Node;\n\n  constructor(node?: Node | null) {\n    if (node === null) {\n      throw new ReferenceError('Reference is null.');\n    }\n    if (node === undefined) {\n      throw new ReferenceError('Reference is undefined.');\n    }\n    this.node = node;\n  }\n\n  as<T extends abstract new (...args: any) => any>(constructor: T): InstanceType<T> {\n    if (this.node instanceof constructor) return this.node as InstanceType<T>;\n    throw new TypeError(`Reference node is not ${constructor}`);\n  }\n  is<T extends abstract new (...args: any) => any>(constructor: T): boolean {\n    return this.node instanceof constructor;\n  }\n  passAs<T extends abstract new (...args: any) => any>(constructor: T, fn: (reference: InstanceType<T>) => void): void {\n    if (this.node instanceof constructor) {\n      fn(this.node as InstanceType<T>);\n    }\n  }\n  tryAs<T extends abstract new (...args: any) => any>(constructor: T): InstanceType<T> | undefined {\n    if (this.node instanceof constructor) {\n      return this.node as InstanceType<T>;\n    }\n  }\n\n  get classList() {\n    return this.as(HTMLElement).classList;\n  }\n  get className() {\n    return this.as(HTMLElement).className;\n  }\n  get style() {\n    return this.as(HTMLElement).style;\n  }\n\n  getAttribute(qualifiedName: string): string | null {\n    return this.as(HTMLElement).getAttribute(qualifiedName);\n  }\n  setAttribute(qualifiedName: string, value: string): void {\n    return this.as(HTMLElement).setAttribute(qualifiedName, value);\n  }\n  getStyleProperty(property: string): string {\n    return this.as(HTMLElement).style.getPropertyValue(property);\n  }\n  setStyleProperty(property: string, value: string | null, priority?: string): void {\n    return this.as(HTMLElement).style.setProperty(property, value, priority);\n  }\n}\nexport function NodeRef(node?: Node | null): CNodeRef {\n  return new CNodeRef(node);\n}\n\nexport class CNodeListRef extends Array<CNodeRef> {\n  constructor(nodes?: NodeList | Node[] | null) {\n    if (nodes === null) {\n      throw new ReferenceError('Reference list is null.');\n    }\n    if (nodes === undefined) {\n      throw new ReferenceError('Reference list is undefined.');\n    }\n    super();\n    for (const node of Array.from(nodes)) {\n      try {\n        this.push(new CNodeRef(node));\n      } catch (_) {}\n    }\n  }\n\n  as<T extends abstract new (...args: any) => any>(constructor: T): Array<InstanceType<T>> {\n    return this.filter((ref) => ref.is(constructor)).map((ref) => ref.as(constructor));\n  }\n\n  passEachAs<T extends abstract new (...args: any) => any>(constructor: T, fn: (reference: InstanceType<T>) => void): void {\n    for (const ref of this) {\n      ref.passAs(constructor, fn);\n    }\n  }\n}\nexport function NodeListRef(nodes?: NodeList | Node[] | null): CNodeListRef {\n  return new CNodeListRef(nodes);\n}\n"
  ],
  "mappings": "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",
  "debugId": "5F21858A30270DC764756E2164756E21",
  "names": []
}